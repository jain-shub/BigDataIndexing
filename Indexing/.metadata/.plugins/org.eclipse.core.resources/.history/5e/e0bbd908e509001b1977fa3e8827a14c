package com.developer.bigdataindexing;

import org.springframework.web.bind.annotation.RestController;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.fge.jsonschema.exceptions.ProcessingException;
import com.github.fge.jsonschema.main.JsonSchemaFactory;
import com.github.fge.jsonschema.main.JsonValidator;
import com.github.fge.jsonschema.report.ProcessingReport;
import com.github.fge.jsonschema.util.JsonLoader;

import redis.clients.jedis.Jedis;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.io.IOUtils;
import org.everit.json.schema.Schema;
import org.everit.json.schema.loader.SchemaLoader;
import org.json.JSONObject;
import org.json.JSONTokener;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
//import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.util.CollectionUtils;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;

@RestController
@RequestMapping("/")
public class BigDataIndexingController {


	private Jedis jedis = new Jedis();
	private JSONParser jsonParser = new JSONParser();

	@RequestMapping("/")
	public String index() {
		return "Greetings from Spring Boot!";
	}

	@PostMapping("/test/add")
	public void testAdd(){
		jedis.set("abc", "{'message': 'This is test!'}");
	}

	@GetMapping("/test/get")
	public ResponseEntity<String> testGet(){

		return ResponseEntity.status(HttpStatus.OK)
				.body(jedis.get("abc"));

	}

	@PostMapping("/add/{type}/{id}")
	public ResponseEntity add(@RequestHeader Map<String, String> headers, @PathVariable String type, @PathVariable String id, @RequestBody String plan){
		//		@RequestHeader("ETag") String eTagVal, 

		String eTag = null;
		String json = null;

		String product = jedis.get(type+"/"+id);
		//		try {
		if(product==null) {
//			System.out.println(plan);
			eTag = eTagGen(plan);
			json = plan;
		}
		else {
			eTag = eTagGen(product);
			json = product;

			//				if(headers.containsKey("If-None-Match") && headers.containsKey("If-Match")) {
			//					return ResponseEntity.status(HttpStatus.BAD_REQUEST)
			//							.body("{'message': Can not have both If-Match and If-None-Match in same operation'}");
			//				}
			//				else if(headers.containsKey("If-None-Match") && headers.get("If-None-Match")==eTag) {
			//					json = jsonParser.parse("{'message': 'Plan provided is already present in database!'}");
			//					return ResponseEntity.status(HttpStatus.NOT_MODIFIED)
			//							.eTag(eTag)
			//							.body(json);
			//				}
			//
			//				else if(headers.containsKey("If-Match") && headers.get("If-Match")!=eTag) {
			//					json = jsonParser.parse("{'message': 'Plan provided not already present in database!'}");
			//					return ResponseEntity.status(HttpStatus.PRECONDITION_FAILED)
			//							.eTag(eTag)
			//							.body(json);
			//				}
			//				else {
			//					eTag = eTagGen(plan);
			//				}
		}

		//			json = jsonParser.parse(plan);

		if(jsonValidator(plan)) {
			jedis.set(type+"/"+id, plan);
		}
		else {
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).
					body("{'message':'JSON validation failed for the input provided'}");
		}

		//		} catch (ParseException e) {
		//			return ResponseEntity.status(HttpStatus.BAD_REQUEST).
		//					body("{'message':'JSON parsing failed for the input provided'}");		
		//		}

		return ResponseEntity.status(HttpStatus.OK)
				.eTag(eTag)
				.body(json);
	}

	public String eTagGen(String plan) {
		String eTag = new DigestUtils("SHA3-256").digestAsHex(plan);
//		System.out.println(eTag);
		return eTag;
	}

	//	public static boolean jsonValidator(JSONObject json) {
	//		JSONObject jsonSchema = new JSONObject(
	//				new JSONTokener(BigDataIndexingApplication.class.getResourceAsStream("./schema.json")));
	//		JSONObject jsonSubject = new JSONObject(
	//				new JSONTokener(json.toString()));
	//
	//		Schema schema = SchemaLoader.load(jsonSchema);
	//		try {
	//			schema.validate(jsonSubject);
	//			System.out.println("Validation Successful");
	//			return true;
	//		}
	//		catch (Exception e) {
	//			System.out.println("Validation exception occured");
	//			return false;
	//		}
	//	}

	public static boolean jsonValidator(String plan) {
		ObjectMapper Obj = new ObjectMapper(); 
//		JsonNode data;
//		JsonNode schema;
		File from = new File("../resources/schema.json");
//		System.out.println(from);
		try {
			JsonNode data = JsonLoader.fromString(plan);
			System.out.println(data);
//			JsonNode schema = JsonLoader.fromString(schemaText);
			JsonNode schema = Obj.readTree(from);
			System.out.println(data);
			System.out.println(schema);
			final JsonSchemaFactory factory = JsonSchemaFactory.byDefault();
			JsonValidator validator = factory.getValidator();
			ProcessingReport report = validator.validate(schema, data);
			System.out.println(report);
			if(report.isSuccess()) {
				return true;
			}
		} catch (JsonProcessingException e) {
			return false;
		} catch (IOException e) {
			return false;
		} catch (ProcessingException e) {
			return false;
		}
		return false;
	}

	public Set<String> findAll(){
		Set<String> sets = jedis.keys("*");
		Set<String> resultSet = new HashSet<>(); 
		if (!CollectionUtils.isEmpty(sets)) {
			for (String key : sets) {
				String result;
				//				try {
				//					result = (JSONObject)jsonParser.parse(jedis.get(key));
				//					result = jsonParser.parse(jedis.get(key));
				result = jedis.get(key);
				resultSet.add((String) result);

				//				} catch (ParseException e) {
				//					return null;
				//				}
			}
		}
		return resultSet;
	}

	@GetMapping("/get/all")
	public ResponseEntity getAll() {
		return ResponseEntity.status(HttpStatus.OK).body(findAll());
	}

	@GetMapping("/get/{type}/{id}")
	public ResponseEntity getById(@RequestHeader Map<String, String> headers, @PathVariable String type, @PathVariable String id) {
		Object json = null;
		String eTag = null;
		if(type==null || id == null) {
			return ResponseEntity.status(HttpStatus.BAD_GATEWAY)
					.body(new JSONObject("{'message':'Id and Type can not be empty'}"));
		}
		else {
			String product = jedis.get(type+"/"+id);
			try {
				if(product==null) {
					return ResponseEntity.status(HttpStatus.NO_CONTENT)
							.body(new JSONObject("{'message':'No entry found for provided key, it has either been deleted or updated', 'status':'204'}"));
				}
				else {
					if(headers.containsKey("If-None-Match") && headers.containsKey("If-Match")) {
						return ResponseEntity.status(HttpStatus.BAD_REQUEST)
								.body("{'message': Can not have both If-Match and If-None-Match in same operation'}");
					}
					else if(headers.containsKey("If-None-Match") && headers.get("If-None-Match")==eTag) {
						//				if(jedis.get(eTag)!=null) {
						//						json = jsonParser.parse("{'message': 'Plan provided is already present in database!'}");
						json = "{'message': 'Plan provided is already present in database!'}";
						return ResponseEntity.status(HttpStatus.NOT_MODIFIED)
								.eTag(eTag)
								.body(json);
						//				}
					}

					else if(headers.containsKey("If-Match") && headers.get("If-Match")!=eTag) {
						//						json = jsonParser.parse("{'message': 'Plan provided not already present in database!'}");
						json = "{'message': 'Plan provided not already present in database!'}";
						return ResponseEntity.status(HttpStatus.PRECONDITION_FAILED)
								.eTag(eTag)
								.body(json);
					}
					else {
						json = jsonParser.parse(product);
					}
				}
			}catch (Exception e) {
				return ResponseEntity.status(HttpStatus.BAD_REQUEST)
						.body("{'message':'JSON parsing failed for the input provided'}");
			}
			//			if(headerETag!=null) {
			//				String currentPlan = jedis.get(headerETag);
			//				if(currentPlan!=null) {
			//					return ResponseEntity.status(HttpStatus.NOT_MODIFIED)
			//							.eTag(headerETag)
			//							.body(new JSONObject("{'message': 'Plan requested is had not been modified!', 'status':'304'}"));
			//				}
			//				else {
			//					return ResponseEntity.status(HttpStatus.NO_CONTENT)
			//							.body(new JSONObject("{'message':'No entry found for provided key, it has either been deleted or updated', 'status':'204'}"));
			//				}
			//			}
			//			else {
			//				Set<String> sets = jedis.keys("*");
			//				if (!CollectionUtils.isEmpty(sets)) {
			//					for (String key : sets) {
			//						JSONObject result;
			//						try {
			//							result = (JSONObject)jsonParser.parse(jedis.get(key));
			//
			//							if(result.getString("objectId").equals(id)) {
			//								json = result;
			//								eTag = key;
			//							}
			//							else {
			//								return ResponseEntity.status(HttpStatus.NO_CONTENT)
			//										.body(new JSONObject("{'message':'No entry found for provided key, it has either been deleted or updated', 'status':'204'}"));
			//							}
			//						} catch (ParseException e) {
			//							return ResponseEntity.status(HttpStatus.BAD_REQUEST)
			//									.body(new JSONObject("{'message':'JSON parsing failed for the input provided', 'status':'400'}"));
			//						}
			//					}
			//				}
			//			}
			return ResponseEntity.status(HttpStatus.OK)
					.eTag(eTag)
					.body(json);
			//		return planRep.findById(id);
		}

	}


	@DeleteMapping("/delete/{type}/{id}")
	public ResponseEntity delete(@RequestHeader Map<String, String> headers, @PathVariable String type, @PathVariable String id) {
		if(type==null || id == null) {
			return ResponseEntity.status(HttpStatus.BAD_GATEWAY)
					.body("{'message':'Id and Type can not be empty'}");
		}
		else {
			String product = jedis.get(type+"/"+id);
			if(product==null) {
				return ResponseEntity.status(HttpStatus.NO_CONTENT)
						.body("{'message':'No entry found for provided key, it has either been deleted or updated'}");
			}
			else {
				jedis.del(type+"/"+id);
			}			
		}
		return ResponseEntity.status(HttpStatus.OK).body(findAll());
	}
}
